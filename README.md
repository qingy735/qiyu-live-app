# QIYU-LIVE-APP

### 1、高并发场景中的用户中台-数据存储与实战
#### 技术要点
- 数据库设计 
        
  **主从数据库** + **分表**
- 读写分离

    **ShardingJDBC** 实现读写分离
- 分布式缓存Redis
 
    使用 **RedisTemplate** 封装组件、查询引入缓存、批量查询设置随机过期时间防止 **缓存雪崩** 、考虑高并发场景下的缓存一致性问题并基于 **RocketMQ** 实现 **延迟双删**
- 分布式ID生成器

    使用 **本地缓存+MySQL** 实现分布式ID生成器

### 2、高并发场景中的用户中台-用户标签
#### 技术要点
- 标签设计
  用户标签采用位运算进行更新。
  > 增加标签：**newTag = oldTag | addTag** 
  > 
  > 取消标签：**newTag = oldTag &~ delTag**
- 引入Redis缓存

  **查询时机**：判断当前用户是否包含某标签，先从Redis缓存中读取，读取到直接返回，未读取到对userId进行查询，查询为空返回null，不为空更新Redis缓存并返回结果

  **删除缓存**：
  
    增加标签：增加成功才删除缓存，否则不操作

    取消标签：取消成功才删除缓存，否则不操作

  > 数据库优化：
  > 
  > 1、在进行更新标签时，除了userId=#{userId}条件外判断当前标签与新增标签进行与是否为0，为0代表当前标签不包含新增标签，可更新；
  >
  > 2、在进行删除标签时，除了userId=#{userId}条件外判断当前标签与新增标签进行与是否为新增标签本身，是就更新；



### 3、高并发场景中的IM服务-分析落地
#### 技术要点
- IM系统对于不同消息包的处理
  > 基于策略模式处理不同消息包的请求，根据不同的消息包code选择不同的处理器
  - 客户端发送登录消息包
  
      im-core-server将用户id和当前连接进行存储<userId, ctx>、<ctx, userId>，并且存储当前用户对应的服务器ip
  
  - 客户端发送业务消息包
  
    im-core-server将客户端消息发送给消息队列，消息服务器拉取消息并将包装ImMsgBody(userId=objectId) 将其发送给路由服务器，路由服务器通过userId获取到接收方客户端对应服务器ip，通过Dubbo中的RpcContext的spi机制，将消息转发给对应服务器进行处理，服务器接收到消息后将消息发送给接收客户端，并将该消息存储进redis(map <msgId, times>)用于ack记录，并且发送延迟消息检验是否收到ack消息
  
  - 客户端发送心跳消息包
  
    im-core-server接收到客户端心跳包消息后将其存入redis中进行存储(zset <key, time>),并清除过期心跳消息和更新当前用户心跳包过期时间、延长用户保存的ip绑定记录时间
  
  - 客户端发送登出消息包
  
    im-core-server清除掉登录时记录的<userId, ctx>、<ctx, userId>信息和客户端绑定服务器ip
  
  - 用户在线探测
  
    通过获取redis中是否还存在当前用户绑定的服务器ip信息
    
- IM系统的Router层设计

  - 根据用户连接的im机器ip实现定向转发
  - 登录时记录用户连接的im机器ip
  - 改写Dubbo底层的cluster

- IM系统的消息确认机制

  接收方收到服务器转发消息后向服务器发送ack消息包，服务器接收到ack消息包后将redis中对应的msgId删除；同时由于发送业务数据包时会附带发送延迟消息，当延迟消息到达后会首先获取重传次数times，如果当前消息已被删除则times=-1，否则进行重传消息，同时记录消息(msg, times+1)、发送延迟消息、重传给客户端，超过允许最大重传次数后结束

### 4、高并发场景中的打赏流程
#### 技术要点
- 送礼链路
  > 用户查询礼物列表 -> 用户点击送礼 -> 后台通过钱包服务查询当前余额是否充足(钱包余额扣减、礼物发送、特效展示、账号信息更新等) -> 送礼流程完毕 

  - 礼物查询

  首先查询redis中是否存有缓存并且判断是否为空值缓存（避免缓存穿透），存在合法缓存则直接返回，否则通过数据库查询并更新redis。礼物列表更新时删除对应缓存，并通过RocketMQ实现延时双删

  - 点击送礼
    - 发送送礼请求
      
      通过RocketMQ发送消息（防止大批量请求同时到来，提升系统并发性），对该送礼请求消息设置唯一id，防止重复消费（id存入redis中，通过setIfAbsent实现）。

    - 余额判断
     
      将用户余额存入redis中防止大量请求直接达到数据库。礼物金额和redis中存入余额进行对比，满足消费要求则进行余额扣减，首先更新redis数据，随后通过异步任务修改数据库（扣减余额，增加流水记录）

  - 礼物展示
    通过方法回传判断送礼是否成功，成功则通过im系统发送给直播间用户送礼特效信息，失败则通过im系统将失败信息发送给送礼用户

- 用户充值
  > 用户通过调用第三方支付接口返回支付二维码等(生成一条支付中状态的订单) -> 业务回调

  首先进行参数校验，然后进行订单生成插入数据库，第三方支付平台将结果返回给支付中台，支付中台对回调信息进行解析包装后将数据发送给bank-provider进行钱包余额增减、账户余额更新、订单更新等操作