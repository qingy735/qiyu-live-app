# QIYU-LIVE-APP

### 1、高并发场景中的用户中台-数据存储与实战
#### 技术要点
- 数据库设计 
        
  **主从数据库** + **分表**
- 读写分离

    **ShardingJDBC** 实现读写分离
- 分布式缓存Redis
 
    使用 **RedisTemplate** 封装组件、查询引入缓存、批量查询设置随机过期时间防止 **缓存雪崩** 、考虑高并发场景下的缓存一致性问题并基于 **RocketMQ** 实现 **延迟双删**
- 分布式ID生成器

    使用 **本地缓存+MySQL** 实现分布式ID生成器

### 2、高并发场景中的用户中台-用户标签
#### 技术要点
- 标签设计
  用户标签采用位运算进行更新。
  > 增加标签：**newTag = oldTag | addTag** 
  > 
  > 取消标签：**newTag = oldTag &~ delTag**
- 引入Redis缓存

  **查询时机**：判断当前用户是否包含某标签，先从Redis缓存中读取，读取到直接返回，未读取到对userId进行查询，查询为空返回null，不为空更新Redis缓存并返回结果

  **删除缓存**：
  
    增加标签：增加成功才删除缓存，否则不操作

    取消标签：取消成功才删除缓存，否则不操作

  > 数据库优化：
  > 
  > 1、在进行更新标签时，除了userId=#{userId}条件外判断当前标签与新增标签进行与是否为0，为0代表当前标签不包含新增标签，可更新；
  >
  > 2、在进行删除标签时，除了userId=#{userId}条件外判断当前标签与新增标签进行与是否为新增标签本身，是就更新；



### 3、高并发场景中的IM服务-分析落地
#### 技术要点
- IM系统对于不同消息包的处理
  > 基于策略模式处理不同消息包的请求，根据不同的消息包code选择不同的处理器
  - 客户端发送登录消息包
  
      im-core-server将用户id和当前连接进行存储<userId, ctx>、<ctx, userId>，并且存储当前用户对应的服务器ip
  
  - 客户端发送业务消息包
  
    im-core-server将客户端消息发送给消息队列，消息服务器拉取消息并将包装ImMsgBody(userId=objectId) 将其发送给路由服务器，路由服务器通过userId获取到接收方客户端对应服务器ip，通过Dubbo中的RpcContext的spi机制，将消息转发给对应服务器进行处理，服务器接收到消息后将消息发送给接收客户端，并将该消息存储进redis(map <msgId, times>)用于ack记录，并且发送延迟消息检验是否收到ack消息
  
  - 客户端发送心跳消息包
  
    im-core-server接收到客户端心跳包消息后将其存入redis中进行存储(zset <key, time>),并清除过期心跳消息和更新当前用户心跳包过期时间、延长用户保存的ip绑定记录时间
  
  - 客户端发送登出消息包
  
    im-core-server清除掉登录时记录的<userId, ctx>、<ctx, userId>信息和客户端绑定服务器ip
  
  - 用户在线探测
  
    通过获取redis中是否还存在当前用户绑定的服务器ip信息
    
- IM系统的Router层设计

  - 根据用户连接的im机器ip实现定向转发
  - 登录时记录用户连接的im机器ip
  - 改写Dubbo底层的cluster

- IM系统的消息确认机制

  接收方收到服务器转发消息后向服务器发送ack消息包，服务器接收到ack消息包后将redis中对应的msgId删除；同时由于发送业务数据包时会附带发送延迟消息，当延迟消息到达后会首先获取重传次数times，如果当前消息已被删除则times=-1，否则进行重传消息，同时记录消息(msg, times+1)、发送延迟消息、重传给客户端，超过允许最大重传次数后结束